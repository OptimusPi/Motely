@using TheFool.Models
@using MudBlazor;
@inject IDialogService DialogService

<MudPaper Class="pa-2" Elevation="2">
    <MudText Typo="Typo.subtitle1" Color="Color.Primary" Class="mb-2">
        ‚öôÔ∏è Configuration Editor
    </MudText>
    
    <MudTabs Elevation="0" Rounded="true" PanelClass="pa-2" @bind-ActivePanelIndex="ActiveTabIndex" Class="compact-tabs">
        <!-- Basic Settings Tab -->
        <MudTabPanel Text="Basic" Icon="@Icons.Material.Filled.Settings">
            <MudGrid Spacing="1">
                <MudItem xs="12">
                    <MudTextField @bind-Value="EditableConfig.Description"
                              Label="Description" 
                                 Variant="Variant.Outlined"
                                 Lines="1"
                                 Margin="Margin.Dense"
                                 OnKeyUp="@(async () => await NotifyConfigChanged())" />
                </MudItem>
                
                <MudItem xs="12" sm="4">
                    <MudTextField @bind-Value="EditableConfig.Author"
                      Label="Author" 
                                 Variant="Variant.Outlined"
                                 Margin="Margin.Dense"
                                 OnKeyUp="@(async () => await NotifyConfigChanged())" />
                </MudItem>
                
                <MudItem xs="12" sm="4">
                    <MudSelect @bind-Value="EditableConfig.Settings.Deck" 
                              Label="Deck" 
                              Variant="Variant.Outlined"
                              Margin="Margin.Dense"
                              OnSelectionChanged="@(async () => await NotifyConfigChanged())">
                        @foreach (var deck in GameData.AvailableDecks)
                        {
                            <MudSelectItem Value="@deck">@FormatDeckName(deck)</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
                
                <MudItem xs="12" sm="4">
                    <MudSelect @bind-Value="EditableConfig.Settings.Stake" 
                              Label="Stake" 
                              Variant="Variant.Outlined"
                              Margin="Margin.Dense"
                              OnSelectionChanged="@(async () => await NotifyConfigChanged())">
                        @foreach (var stake in GameData.AvailableStakes)
                        {
                            <MudSelectItem Value="@stake">@FormatStakeName(stake)</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
                
                <MudItem xs="12" sm="8">
                    <MudTextField @bind-Value="KeywordsText" 
                                 Label="Keywords (comma-separated)" 
                                 Variant="Variant.Outlined"
                                 Margin="Margin.Dense"
                                 OnKeyUp="@(async () => await NotifyConfigChanged())" />
                </MudItem>
                
                <MudItem xs="12" sm="4">
                     <MudText Typo="Typo.body2" Class="mb-1">Ante Range: @((int)AnteRange[0])-@((int)AnteRange[1])</MudText>
                     <MudGrid Spacing="0">
                         <MudItem xs="6">
                             <MudText Typo="Typo.caption">Min: @((int)AnteRange[0])</MudText>
                             <MudSlider T="int" @bind-Value="AnteRange[0]" 
                                       Min="1" Max="@((int)AnteRange[1])" Step="1" Color="Color.Primary" />
                         </MudItem>
                         <MudItem xs="6">
                             <MudText Typo="Typo.caption">Max: @((int)AnteRange[1])</MudText>
                             <MudSlider T="int" @bind-Value="AnteRange[1]" 
                                       Min="@((int)AnteRange[0])" Max="8" Step="1" Color="Color.Primary" />
                         </MudItem>
                     </MudGrid>
                 </MudItem>
            </MudGrid>
        </MudTabPanel>
        
        <!-- Scoring Tab -->
        <MudTabPanel Text="Scoring" Icon="@Icons.Material.Filled.Score">
            <MudGrid Spacing="1">
                <MudItem xs="12" sm="6">
                    <MudCheckBox T="bool" Checked="EditableConfig.Settings.ScoreNaturalNegatives" 
                                CheckedChanged="@(async (bool newValue) => { EditableConfig.Settings.ScoreNaturalNegatives = newValue; await NotifyConfigChanged(); })"
                                Label="Score Natural Negatives" 
                                Dense="true"
                                Color="Color.Success" />
                </MudItem>
                
                <MudItem xs="12" sm="6">
                    <MudCheckBox T="bool" Checked="EditableConfig.Settings.ScoreDesiredNegatives" 
                                CheckedChanged="@(async (bool newValue) => { EditableConfig.Settings.ScoreDesiredNegatives = newValue; await NotifyConfigChanged(); })"
                                Label="Score Desired Negatives" 
                                Dense="true"
                                Color="Color.Info" />
                </MudItem>
            </MudGrid>
        </MudTabPanel>
        
        <!-- Needs Tab -->
        <MudTabPanel Text="@($"Needs ({EditableConfig.Settings.Needs.Count})")"
                     Icon="@Icons.Material.Filled.Favorite"
                     BadgeData="@EditableConfig.Settings.Needs.Count"
                     BadgeColor="Color.Primary">
            <MudButton Color="Color.Primary" 
                      Variant="Variant.Filled" 
                      StartIcon="@Icons.Material.Filled.Add"
                      Size="Size.Small"
                      Class="mb-2"
                      OnClick="() => OpenConditionDialog(true)">
                Add Need
            </MudButton>
            
            <MudStack Spacing="1">
                @foreach (var need in EditableConfig.Settings.Needs)
                {
                    <ConditionCard Condition="need" 
                                 OnRemove="() => RemoveCondition(need, true)"
                                 OnEdit="() => EditCondition(need, true)" />
                }
            </MudStack>
            
            @if (!EditableConfig.Settings.Needs.Any())
            {
                <MudText Typo="Typo.body2" Color="Color.Tertiary" Align="Align.Center" Class="mt-2">
                    No needs configured. Add conditions that MUST be met.
                </MudText>
            }
        </MudTabPanel>
        
        <!-- Wants Tab -->
        <MudTabPanel Text="@($"Wants ({EditableConfig.Settings.Wants.Count})")"
                     Icon="@Icons.Material.Filled.FavoriteBorder"
                     BadgeData="@EditableConfig.Settings.Wants.Count"
                     BadgeColor="Color.Secondary">
            <MudButton Color="Color.Secondary" 
                      Variant="Variant.Filled" 
                      StartIcon="@Icons.Material.Filled.Add"
                      Size="Size.Small"
                      Class="mb-2"
                      OnClick="() => OpenConditionDialog(false)">
                Add Want
            </MudButton>
            
            <MudStack Spacing="1">
                @foreach (var want in EditableConfig.Settings.Wants)
                {
                    <ConditionCard Condition="want" 
                                 OnRemove="() => RemoveCondition(want, false)"
                                 OnEdit="() => EditCondition(want, false)" />
                }
            </MudStack>
            
            @if (!EditableConfig.Settings.Wants.Any())
            {
                <MudText Typo="Typo.body2" Color="Color.Tertiary" Align="Align.Center" Class="mt-2">
                    No wants configured. Add optional conditions for scoring.
                </MudText>
            }
        </MudTabPanel>
    </MudTabs>
</MudPaper>

@code {
    [Parameter] public FilterConfig Config { get; set; }
    [Parameter] public EventCallback<FilterConfig> ConfigChanged { get; set; }

    private FilterConfig EditableConfig;
    private int ActiveTabIndex = 0;
    private int[] AnteRange = new[] { 1, 8 };
    private string KeywordsText = "";

    protected override void OnParametersSet()
    {
        // Create a deep copy for editing
        EditableConfig = DeepCopy(Config);
        KeywordsText = string.Join(", ", EditableConfig.Keywords);
        AnteRange = new[] { 
            EditableConfig.Settings.MinSearchAnte, 
            EditableConfig.Settings.MaxSearchAnte 
        };
    }

    private async Task UpdateConfig(Action<FilterConfig> updateAction)
    {
        updateAction(EditableConfig);
        await NotifyConfigChanged();
    }

    private async Task NotifyConfigChanged()
    {
        var newKeywords = KeywordsText.Split(',', StringSplitOptions.RemoveEmptyEntries)
                                    .Select(k => k.Trim())
                                    .ToArray();

        // Update settings properties directly since FilterSettings is a class

        EditableConfig.Keywords = newKeywords.ToList();
        EditableConfig.Settings.MinSearchAnte = (int)AnteRange[0];
        EditableConfig.Settings.MaxSearchAnte = (int)AnteRange[1];
        
        await ConfigChanged.InvokeAsync(EditableConfig);
    }

    private void RemoveCondition(FilterCondition condition, bool isNeed)
    {
        if (condition.Type == "Need")
        {
            EditableConfig.Settings.Needs = EditableConfig.Settings.Needs.Where(c => c != condition).ToList();
        }
        else
        {
            EditableConfig.Settings.Wants = EditableConfig.Settings.Wants.Where(c => c != condition).ToList();
        }
        
        _ = NotifyConfigChanged();
    }

    private async Task OpenConditionDialog(bool isNeed)
    {
        var parameters = new DialogParameters
        {
            ["IsNeed"] = isNeed,
            ["ExistingCondition"] = null
        };
        
        var dialog = await DialogService.ShowAsync<ConditionEditorDialog>(
            isNeed ? "Add Need" : "Add Want", 
            parameters,
            new DialogOptions { MaxWidth = MaxWidth.Small, FullWidth = true });
        
        var result = await dialog.Result;
        if (result != null && !result.Canceled && result.Data is FilterCondition newCondition)
        {
            if (newCondition.Type == "Need")
            {
                if (EditableConfig?.Settings?.Needs != null)
                {
                    EditableConfig.Settings.Needs.Add(newCondition);
                }
            }
        else
        {
            EditableConfig?.Settings?.Wants?.Add(newCondition);
        }
            
            await NotifyConfigChanged();
        }
    }

    private async Task EditCondition(FilterCondition condition, bool isNeed)
    {
        var parameters = new DialogParameters
        {
            ["IsNeed"] = isNeed,
            ["ExistingCondition"] = condition
        };
        
        var dialog = await DialogService.ShowAsync<ConditionEditorDialog>(
            "Edit Condition", 
            parameters,
            new DialogOptions { MaxWidth = MaxWidth.Small, FullWidth = true });
        
        var result = await dialog.Result;
        if (result != null && !result.Canceled && result.Data is FilterCondition editedCondition)
        {
            var sourceList = isNeed ? EditableConfig?.Settings?.Needs : EditableConfig?.Settings?.Wants;
            if (sourceList != null)
            {
                var list = sourceList.ToList();
                var index = list.IndexOf(condition);
                if (index >= 0)
                {
                    list[index] = editedCondition;

                if (isNeed)
                {
                    if (EditableConfig?.Settings != null)
                        EditableConfig.Settings.Needs = list;
                }
                else
                {
                    if (EditableConfig?.Settings != null)
                        EditableConfig.Settings.Wants = list;
                }
                await NotifyConfigChanged();
                }
            }
        }
    }

    private FilterConfig DeepCopy(FilterConfig original)
    {
        // Simple deep copy using JSON serialization
        var json = System.Text.Json.JsonSerializer.Serialize(original);
        return System.Text.Json.JsonSerializer.Deserialize<FilterConfig>(json);
    }

    private string FormatDeckName(string deck)
    {
        return deck switch
        {
            "RedDeck" => "üî¥ Red Deck",
            "BlueDeck" => "üîµ Blue Deck",
            "YellowDeck" => "üü° Yellow Deck",
            "GreenDeck" => "üü¢ Green Deck",
            "BlackDeck" => "‚ö´ Black Deck",
            "MagicDeck" => "üé© Magic Deck",
            "NebuladDeck" => "üåå Nebula Deck",
            "GhostDeck" => "üëª Ghost Deck",
            "AbandonedDeck" => "üèöÔ∏è Abandoned Deck",
            "CheckeredDeck" => "üèÅ Checkered Deck",
            "ZodiacDeck" => "‚ôà Zodiac Deck",
            "PaintedDeck" => "üé® Painted Deck",
            "AnaglyphDeck" => "üï∂Ô∏è Anaglyph Deck",
            "PlasmaDeck" => "‚ö° Plasma Deck",
            "ErraticdDeck" => "üé≤ Erratic Deck",
            "ChallengeDeck" => "üèÜ Challenge Deck",
            _ => deck
        };
    }
    
    private string FormatStakeName(string stake)
    {
        return stake switch
        {
            "WhiteStake" => "‚ö™ White Stake",
            "RedStake" => "üî¥ Red Stake",
            "GreenStake" => "üü¢ Green Stake",
            "BlackStake" => "‚ö´ Black Stake",
            "BlueStake" => "üîµ Blue Stake",
            "PurpleStake" => "üü£ Purple Stake",
            "OrangeStake" => "üü† Orange Stake",
            "GoldStake" => "üü° Gold Stake",
            _ => stake
        };
    }

    // Static game data
    private static class GameData
    {
        public static readonly List<string> AvailableDecks = new()
        {
            "RedDeck", "BlueDeck", "YellowDeck", "GreenDeck", "BlackDeck",
            "MagicDeck", "NebuladDeck", "GhostDeck", "AbandonedDeck", 
            "CheckeredDeck", "ZodiacDeck", "PaintedDeck", "AnaglyphDeck",
            "PlasmaDeck", "ErraticdDeck", "ChallengeDeck"
        };

        public static readonly List<string> AvailableStakes = new()
        {
            "WhiteStake", "RedStake", "GreenStake", "BlackStake",
            "BlueStake", "PurpleStake", "OrangeStake", "GoldStake"
        };
    }
}
