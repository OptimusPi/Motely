using System;
using System.IO;
using System.Reflection;
using Avalonia;
using Avalonia.Rendering.Composition;
using Avalonia.Skia;
using Avalonia.Platform;
using SkiaSharp;
using Motely.TheFool.Extensions;

namespace Motely.TheFool.Controls;

/// <summary>
/// Custom visual handler that renders the Balatro background effect using SkiaSharp shaders.
/// Runs on the render thread for optimal performance.
/// </summary>
internal sealed class BalatroBkgndVisualHandler : CompositionCustomVisualHandler, IDisposable
{
    private readonly BalatroBkgnd _control;
    private SKRuntimeEffect? _effect;
    private DateTime _startTime;
    private string? _shaderSource;
    private bool _disposed;
    
    public BalatroBkgndVisualHandler(BalatroBkgnd control)
    {
        _control = control ?? throw new ArgumentNullException(nameof(control));
        _startTime = DateTime.Now;
    }
    
    public override void OnRender(IDrawingContext context)
    {
        if (_disposed) return;
        
        // Lazy load and compile shader
        if (_effect == null)
        {
            if (_shaderSource == null)
            {
                _shaderSource = LoadShaderSource();
            }
            
            _effect = SKRuntimeEffect.Create(_shaderSource, out var errorText);
            if (_effect == null)
            {
                System.Diagnostics.Debug.WriteLine($"Shader compilation failed: {errorText}");
                // Fall back to solid color on shader compilation failure
                DrawFallback(context);
                return;
            }
        }
        
        var bounds = GetRenderBounds();
        if (bounds.Width <= 0 || bounds.Height <= 0) return;
        
        var leaseFeature = context.TryGetFeature<ISkiaSharpApiLeaseFeature>();
        if (leaseFeature == null) return;
        
        using var lease = leaseFeature.Lease();
        var canvas = lease.SkCanvas;
        if (canvas == null) return;
        
        // Calculate animation time
        var elapsed = (float)(DateTime.Now - _startTime).TotalSeconds;
        
        // Convert Avalonia colors to SkiaSharp
        var color1 = ToSKColor(_control.Color1);
        var color2 = ToSKColor(_control.Color2);
        var color3 = ToSKColor(_control.Color3);
        
        // Create shader uniforms
        using var uniformData = new SKRuntimeEffectUniforms(_effect)
        {
            ["iTime"] = elapsed,
            ["iResolution"] = new[] { (float)bounds.Width, (float)bounds.Height },
            ["spin_rotation_speed"] = (float)_control.SpinSpeed,
            ["move_speed"] = (float)_control.MoveSpeed,
            ["offset"] = new[] { 0f, 0f },
            ["colour_1"] = color1.ToShaderArray(),
            ["colour_2"] = color2.ToShaderArray(),
            ["colour_3"] = color3.ToShaderArray(),
            ["contrast"] = (float)_control.Contrast,
            ["lighting"] = (float)_control.Lighting,
            ["spin_amount"] = (float)_control.SpinAmount,
            ["pixel_filter"] = (float)_control.PixelFilter
        };
        
        // Create and apply shader
        using var shader = _effect.ToShader(false, uniformData);
        using var paint = new SKPaint
        {
            Shader = shader,
            IsAntialias = false, // Keep pixelated look
            FilterQuality = SKFilterQuality.None
        };
        
        // Draw the effect
        canvas.DrawRect(SKRect.Create((float)bounds.Width, (float)bounds.Height), paint);
    }
    
    public override void OnAnimationFrameUpdate()
    {
        if (!_disposed)
        {
            // Request next frame for continuous animation
            Invalidate();
        }
    }
    
    private void DrawFallback(IDrawingContext context)
    {
        // Simple gradient fallback if shader fails
        var bounds = GetRenderBounds();
        var leaseFeature = context.TryGetFeature<ISkiaSharpApiLeaseFeature>();
        if (leaseFeature == null) return;
        
        using var lease = leaseFeature.Lease();
        var canvas = lease.SkCanvas;
        
        using var paint = new SKPaint();
        var colors = new[]
        {
            ToSKColor(_control.Color1),
            ToSKColor(_control.Color2),
            ToSKColor(_control.Color3)
        };
        
        paint.Shader = SKShader.CreateLinearGradient(
            new SKPoint(0, 0),
            new SKPoint((float)bounds.Width, (float)bounds.Height),
            colors,
            null,
            SKShaderTileMode.Clamp);
        
        canvas.DrawRect(SKRect.Create((float)bounds.Width, (float)bounds.Height), paint);
    }
    
    private string LoadShaderSource()
    {
        try
        {
            // Try to load from embedded resource first
            var assembly = Assembly.GetExecutingAssembly();
            var resourceName = "Motely.TheFool.Shaders.balatro_background.sksl";
            
            using var stream = assembly.GetManifestResourceStream(resourceName);
            if (stream != null)
            {
                using var reader = new StreamReader(stream);
                return reader.ReadToEnd();
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to load embedded shader: {ex.Message}");
        }
        
        // Fall back to loading from file system
        try
        {
            var shaderPath = Path.Combine(
                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? "",
                "Shaders",
                "balatro_background.sksl");
            
            if (File.Exists(shaderPath))
            {
                return File.ReadAllText(shaderPath);
            }
            
            // Try alternative path
            shaderPath = Path.Combine("Shaders", "balatro_background.sksl");
            if (File.Exists(shaderPath))
            {
                return File.ReadAllText(shaderPath);
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to load shader from file: {ex.Message}");
        }
        
        // Return inline shader as last resort
        return @"
uniform float iTime;
uniform float2 iResolution;
uniform float spin_rotation_speed;
uniform float move_speed;
uniform float2 offset;
uniform float4 colour_1;
uniform float4 colour_2;
uniform float4 colour_3;
uniform float contrast;
uniform float lighting;
uniform float spin_amount;
uniform float pixel_filter;

float4 main(float2 fragCoord) {
    // Pixelation effect
    float pixel_size = length(iResolution) / pixel_filter;
    float2 screen_coords = fragCoord;
    
    // Flip Y coordinate for AvaloniaUI coordinate system
    screen_coords.y = iResolution.y - screen_coords.y;
    
    float2 uv = (floor(screen_coords * (1.0 / pixel_size)) * pixel_size - 0.5 * iResolution) / length(iResolution) - offset;
    
    // Polar coordinate swirl
    float uv_len = length(uv);
    float speed = (spin_rotation_speed * 0.2) + 302.2;
    float angle = atan(uv.y, uv.x);
    float new_angle = angle + speed - 20.0 * (spin_amount * uv_len + (1.0 - spin_amount));
    
    uv = float2(cos(new_angle), sin(new_angle)) * uv_len;
    
    // Paint distortion loop
    uv *= 30.0;
    speed = iTime * move_speed;
    float2 uv2 = float2(uv.x + uv.y);
    
    for (int i = 0; i < 5; i++) {
        uv2 += sin(max(uv.x, uv.y)) + uv;
        uv += 0.5 * float2(cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121), 
                          sin(uv2.x - 0.113 * speed));
        uv -= 1.0 * cos(uv.x + uv.y) - 1.0 * sin(uv.x * 0.711 - uv.y);
    }
    
    // Color mixing
    float contrast_mod = (0.25 * contrast + 0.5 * spin_amount + 1.2);
    float paint_res = min(2.0, max(0.0, length(uv) * 0.035 * contrast_mod));
    float c1p = max(0.0, 1.0 - contrast_mod * abs(1.0 - paint_res));
    float c2p = max(0.0, 1.0 - contrast_mod * abs(paint_res));
    float c3p = 1.0 - min(1.0, c1p + c2p);
    
    // Lighting
    float light = (lighting - 0.2) * max(c1p * 5.0 - 4.0, 0.0) + 
                  lighting * max(c2p * 5.0 - 4.0, 0.0);
    
    // Final color composition
    float3 color = colour_1.rgb * c1p + colour_2.rgb * c2p + colour_3.rgb * c3p + float3(light);
    
    return float4(color, 1.0);
}";
    }
    
    private static SKColor ToSKColor(Avalonia.Media.Color color)
    {
        return new SKColor(color.R, color.G, color.B, color.A);
    }
    
    public void Dispose()
    {
        if (_disposed) return;
        
        _disposed = true;
        _effect?.Dispose();
        _effect = null;
    }
}
